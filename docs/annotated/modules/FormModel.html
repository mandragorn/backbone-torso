<!DOCTYPE html>

<html>
<head>
  <title>FormModel.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="Behavior.html">
                  modules/Behavior.js
                </a>
              
                
                <a class="source" href="Cell.html">
                  modules/Cell.js
                </a>
              
                
                <a class="source" href="Collection.html">
                  modules/Collection.js
                </a>
              
                
                <a class="source" href="Events.html">
                  modules/Events.js
                </a>
              
                
                <a class="source" href="FormModel.html">
                  modules/FormModel.js
                </a>
              
                
                <a class="source" href="FormView.html">
                  modules/FormView.js
                </a>
              
                
                <a class="source" href="ListView.html">
                  modules/ListView.js
                </a>
              
                
                <a class="source" href="Model.html">
                  modules/Model.js
                </a>
              
                
                <a class="source" href="NestedCell.html">
                  modules/NestedCell.js
                </a>
              
                
                <a class="source" href="NestedModel.html">
                  modules/NestedModel.js
                </a>
              
                
                <a class="source" href="Router.html">
                  modules/Router.js
                </a>
              
                
                <a class="source" href="ServiceCell.html">
                  modules/ServiceCell.js
                </a>
              
                
                <a class="source" href="View.html">
                  modules/View.js
                </a>
              
                
                <a class="source" href="behaviors/DataBehavior.html">
                  modules/behaviors/DataBehavior.js
                </a>
              
                
                <a class="source" href="configure.html">
                  modules/configure.js
                </a>
              
                
                <a class="source" href="handlebarsUtils.html">
                  modules/handlebarsUtils.js
                </a>
              
                
                <a class="source" href="history.html">
                  modules/history.js
                </a>
              
                
                <a class="source" href="mixins/cacheMixin.html">
                  modules/mixins/cacheMixin.js
                </a>
              
                
                <a class="source" href="mixins/cellMixin.html">
                  modules/mixins/cellMixin.js
                </a>
              
                
                <a class="source" href="mixins/loadingMixin.html">
                  modules/mixins/loadingMixin.js
                </a>
              
                
                <a class="source" href="mixins/modelMixin.html">
                  modules/mixins/modelMixin.js
                </a>
              
                
                <a class="source" href="mixins/pollingMixin.html">
                  modules/mixins/pollingMixin.js
                </a>
              
                
                <a class="source" href="registry.html">
                  modules/registry.js
                </a>
              
                
                <a class="source" href="stickitUtils.html">
                  modules/stickitUtils.js
                </a>
              
                
                <a class="source" href="templateRenderer.html">
                  modules/templateRenderer.js
                </a>
              
                
                <a class="source" href="torso.html">
                  modules/torso.js
                </a>
              
                
                <a class="source" href="validation.html">
                  modules/validation.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>FormModel.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="hljs-string">'underscore'</span>, <span class="hljs-string">'backbone'</span>, <span class="hljs-string">'./NestedModel'</span>, <span class="hljs-string">'./validation'</span>], factory);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {
    <span class="hljs-built_in">module</span>.exports = factory(<span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'./NestedModel'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">'./validation'</span>));
  } <span class="hljs-keyword">else</span> {
    root.Torso = root.Torso || {};
    root.Torso.FormModel = factory(root._, root.Backbone, root.Torso.NestedModel, root.Torso.validation);
  }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_, Backbone, NestedModel, validation</span>) </span>{
<span class="hljs-meta">  'use strict'</span>;

  <span class="hljs-keyword">var</span> $ = Backbone.$;

  <span class="hljs-comment">/**
   * Generic Form Model
   *
   * @class FormModel
   * @extends NestedModel
   * @mixes validationMixin
   *
   * @author kent.willis@vecna.com
   *
   * @see &lt;a href="../annotated/modules/FormModel.html"&gt;FormModel Annotated Source&lt;/a&gt;
   */</span>
  <span class="hljs-keyword">var</span> FormModel = NestedModel.extend(<span class="hljs-comment">/** @lends FormModel# */</span>{
    <span class="hljs-comment">/**
     * @private
     * @property __currentMappings
     * @type Object
     */</span>
    <span class="hljs-comment">/**
     * @private
     * @property __cache
     * @type Object
     */</span>
    <span class="hljs-comment">/**
     * @private
     * @property __currentObjectModels
     * @type Object
     */</span>
    <span class="hljs-comment">/**
     * @private
     * @property __currentUpdateEvents
     * @type Array
     */</span>
    <span class="hljs-comment">/**
     * @property validation
     * @type Object
     */</span>
    <span class="hljs-comment">/**
     * @property labels
     * @type Object
     */</span>
    <span class="hljs-comment">/**
     * Map from aliases (either model names or computed value names) to mappings.
     * Please refer to the documentation on the constructor about the form and options for this field.
     * @property mapping
     * @type Object
     */</span>
    mapping: <span class="hljs-literal">undefined</span>,

    <span class="hljs-comment">/**
     * Map from model aliases to model instances.
     * Please refer to the documentation on the constructor about the form and options for this field.
     * @property models
     * @type Object
     */</span>
    models: <span class="hljs-literal">undefined</span>,

    <span class="hljs-comment">/**
     * Constructor the form model. Can take in attributes to set initially. These will override any pulled values from object models
     * on initialization. On initialization the object model's values will be pulled once.
     * For the options, here are needed definitions:
     * mapping: {
     *   modelName: 'foo bar baz' // track a model by providing an alias for a name and a space seperated list of fields to track as a String
     *   modelName2: true          // to track all fields
     *   ...                      // can have many model mappings
     *   computedName: {
     *     modelName: 'taz raz',  // mappings for models that will be used for this computed mapping.
     *     ...                    // can have many model mappings for a computed
     *     pull: function(models) {}, // a callback that will be invoked when pulling data from the Object model. Passes in a map of model alias/name to shallow copies of fields being tracked on that model.
     *     push: function(models) {}  // a callback that will be invoked when pushing data to the Object model. Passes in a map of model alias/name to object model being tracked under that alias.
     *   }
     * },
     * models: {
     *   modelName: modelInstance,  // optionally, provide a set of model instance to model name (aliases) to start tracking
     *   modelName2: modelInstance2 // provide as many aliases to model instances as you'd like
     * }
     * @param {Object} [options]
     *   @param {Object} [options.mapping] map from aliases (either model names or computed value names) to mappings.
     *     A model mapping can bind an alias to a space seperated list of fields to track as a String  r the boolean true if it is mapping all the
     *     fields. A computed mapping can bind an alias to a set of model mappings required for this computed value and both a pull and/or push method
     *     that are used to compute different values to or from object model(s).
     *   @param {Object} [options.models] Because the options.mapping parameter only allows you to define the mappings to aliases, this options allows
     *     you to bind model instances to aliases. Setting model instances to aliases are required to actually begin pulling/pushing values.
     *   @param {boolean} [options.startUpdating=false] set to true if you want to immediately set up listeners to update this form
     *     model as the object model updates. You can always toggle this state with startUpdating() and stopUpdating().
     *   @param {Object} [options.validation] A Backbone.Validation plugin hash to dictate the validation rules
     *   @param {Object} [options.labels] A Backbone.Validation plugin hash to dictate the attribute labels
     */</span>
    <span class="hljs-keyword">constructor</span>: function(attributes, options) {
      options = options || {};
      <span class="hljs-keyword">this</span>.__cache = {};
      <span class="hljs-keyword">this</span>.__currentUpdateEvents = [];
      <span class="hljs-keyword">this</span>.__currentMappings = {};
      <span class="hljs-keyword">this</span>.__currentObjectModels = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>override + extend the validation and labels hashes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.validation = _.extend({}, <span class="hljs-keyword">this</span>.validation, options.validation);
      <span class="hljs-keyword">this</span>.labels = _.extend({}, <span class="hljs-keyword">this</span>.labels, options.labels);

      NestedModel.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

      <span class="hljs-keyword">this</span>.__initMappings(options);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Do an initial pull</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.pull();</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The pull may have overridden default attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (attributes) {
        <span class="hljs-keyword">this</span>.set(attributes);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Begin updating if requested</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (options.startUpdating) {
        <span class="hljs-keyword">this</span>.startUpdating();
      }
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'initialization-complete'</span>);
    },

    <span class="hljs-comment">/**
     * @param {string} alias the alias of the mapping - either a model mapping or a computed mapping
     * @returns the mapping config for that alias
     */</span>
    getMapping: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__currentMappings[alias];
    },

    <span class="hljs-comment">/**
     * @returns all the current mapping configs
     */</span>
    getMappings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__currentMappings;
    },

    <span class="hljs-comment">/**
     * Define or redefine how the form model pull/pushes or otherwise tracks properties between an object model(s).
     * Examples:
     * this.setMapping('modelAlias', true, optional model instance);
     * this.setMapping('modelAlias, 'foo bar baz', optional model instance);
     * this.setMapping('computedAlias', {
     *   model1: 'foo',
     *   model2: 'bar',
     *   push: function(models) {
     *     models.model1.set('foo', this.get('foobar')[0]);
     *     models.model2.set('bar', this.get('foobar')[1]);
     *   },
     *   pull: function(models) {
     *     this.set('foobar', [models.model1.foo, models.model2.bar]);
     *   },
     * }, optional model map)
     * @param {string} alias the name for the mapping - either a model mapping or a computed mapping
     * @param {(string|boolean|Object)} mapping Provides the mapping for this alias. If trying to map to a model, then either provide
     *  a space delimited list of fields to track as a String or the boolean true to track all the model's fields. If the mapping is for
     *  a computed value, then provide a map from model alias to model mapping for all the fields needed for the computed and a pull method
     *  if you want to change/combine/split object model properties before bringing them into the form model and a push method if you want to
     *  change/combine/split form model properties before pushing them to the object models.
     * @param {Object|external:Backbone-Model} [models] Provides instances to use for this mapping. If mapping is a computed,
     *   provide a map from alias to model instance. If mapping is for a single model, just provide the model instance for that alias.
     * @param [copy=false] if true, will pull values definined by this mapping after setting the mapping. Requires models to be passed in.
     */</span>
    setMapping: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias, mapping, models, copy</span>) </span>{
      <span class="hljs-keyword">var</span> computed, fields,
        config = {};
      <span class="hljs-keyword">if</span> (_.isString(mapping)) {
        fields = mapping.split(<span class="hljs-string">' '</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mapping === <span class="hljs-literal">true</span>) {
        fields = <span class="hljs-literal">undefined</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isObject(mapping)) {
        mapping = _.clone(mapping);
        computed = <span class="hljs-literal">true</span>;
      }
      config.computed = computed;
      <span class="hljs-keyword">if</span> (computed) {
        config.mapping = mapping;
        _.each(<span class="hljs-keyword">this</span>.__getModelAliases(config), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
          <span class="hljs-keyword">var</span> configMappingForAlias = config.mapping[modelAlias];
          <span class="hljs-keyword">if</span> (_.isString(configMappingForAlias)) {
            configMappingForAlias = configMappingForAlias.split(<span class="hljs-string">' '</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (configMappingForAlias === <span class="hljs-literal">true</span>) {
            configMappingForAlias = <span class="hljs-literal">undefined</span>;
          }
          config.mapping[modelAlias] = configMappingForAlias;
        });
      } <span class="hljs-keyword">else</span> {
        config.mapping = fields;
      }
      <span class="hljs-keyword">this</span>.__currentMappings[alias] = config;
      <span class="hljs-keyword">if</span> (models) {
        <span class="hljs-keyword">if</span> (computed) {
          <span class="hljs-keyword">this</span>.trackModels(models, copy);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.trackModel(alias, models, copy);
        }
      }
    },

    <span class="hljs-comment">/**
     * Sets multiple mappings (both model mappings and computed value mappings) with one call.
     * Uses the same style of mapping syntax as the constructor. Please refer to the documentation on the constructor.
     * Here is an example:
     * this.setMappings({
     *   model1: 'foo bar',
     *   model2: 'baz',
     *   ssn: {
     *     model1: 'ssn',
     *     model2: 'lastssn'
     *     push: function(models) {},
     *     pull: function(models) {},
     *   }
     * }, optional model map)
     * @param {Object} mappings Uses the same style of mapping syntax as the constructor. Please refer to the documentation on the constructor.
     * @param {Object} [models] this parameter allows you to immediately bind model instances to aliases. Keys are aliases and values are external:Backbone-Models.
     * @param [copy=false] if true, will pull values definined by this mapping after setting the mapping. Requires models to be passed in.
     */</span>
    setMappings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mappings, models, copy</span>) </span>{
      _.each(mappings, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mapping, alias</span>) </span>{
        <span class="hljs-keyword">this</span>.setMapping(alias, mapping);
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">if</span> (models) {
        <span class="hljs-keyword">this</span>.trackModels(models, copy);
      }
    },

    <span class="hljs-comment">/**
     * Remove a mapping (model or computed) by alias
     * @param {string|external:Backbone-Model} aliasOrModel if a String is provided, it will unset the mapping with that alias.
     *   If a external:Backbone-Model is provided, it will remove the model mapping that was bound to that model.
     * @param {boolean} [removeModelIfUntracked=false] If true, after the mapping is removed, the model will also be unset but only if
     *   no other mappings reference it. Note, setting this to true will not remove any computed mappings that also use that model.
     */</span>
    unsetMapping: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aliasOrModel, removeModelIfUntracked</span>) </span>{
      <span class="hljs-keyword">var</span> alias = <span class="hljs-keyword">this</span>.__findAlias(aliasOrModel);
      <span class="hljs-keyword">if</span> (alias) {
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.__currentMappings[alias];
      }
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(alias);
      <span class="hljs-keyword">if</span> (removeModelIfUntracked &amp;&amp; model &amp;&amp; _.isEmpty(<span class="hljs-keyword">this</span>.__getTrackedModelFields(model))) {
        <span class="hljs-keyword">this</span>.untrackModel(model);
      }
    },

    <span class="hljs-comment">/**
     * Removes all current mappings
     * Does NOT remove current model being tracked. Call this.untrackModels afterwards if you wish this behavior.
     */</span>
    unsetMappings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.__currentMappings = {};
      <span class="hljs-keyword">this</span>.resetUpdating();
    },

    <span class="hljs-comment">/**
     * Returns the object model currently bound to the given name/alias.
     * @param {string} alias the name/alias used by the mappings.
     * @returns {external:Backbone-Model} the model currently bound to the alias
     */</span>
    getTrackedModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__currentObjectModels[alias];
    },

    <span class="hljs-comment">/**
     * Returns all the currently tracked object models
     * @returns all the currently tracked object models
     */</span>
    getTrackedModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _.values(<span class="hljs-keyword">this</span>.__currentObjectModels);
    },

    <span class="hljs-comment">/**
     * Use {@link FormModel#trackModel} instead.
     * @see {@link FormModel#trackModel}
     * @deprecated
     */</span>
    setTrackedModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.trackModel.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },

    <span class="hljs-comment">/**
     * Update or create a binding between an object model and an alias.
     * @param {string} alias the alias/name to bind to.
     * @param {external:Backbone-Model} model the model to be bound. Mappings referencing this alias will start applying to this model.
     * @param {boolean} [copy=false] if true, the form model will perform a pull on any mappings using this alias.
     */</span>
    trackModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias, model, copy</span>) </span>{
      <span class="hljs-keyword">this</span>.__currentObjectModels[alias] = model;
      <span class="hljs-keyword">this</span>.__updateCache(model);
      <span class="hljs-keyword">this</span>.resetUpdating();
      <span class="hljs-keyword">if</span> (copy) {
        _.each(<span class="hljs-keyword">this</span>.getMappings(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, mappingAlias</span>) </span>{
          <span class="hljs-keyword">var</span> modelAliases;
          <span class="hljs-keyword">if</span> (alias === mappingAlias) {
            <span class="hljs-keyword">this</span>.__pull(mappingAlias);
          }
          <span class="hljs-keyword">if</span> (config.computed) {
            modelAliases = <span class="hljs-keyword">this</span>.__getModelAliases(mappingAlias);
            <span class="hljs-keyword">if</span> (_.contains(modelAliases, alias)) {
              <span class="hljs-keyword">this</span>.__pull(mappingAlias);
            }
          }
        }, <span class="hljs-keyword">this</span>);
      }
    },

    <span class="hljs-comment">/**
     * Use {@link FormModel#trackModels} instead.
     * @see {@link FormModel#trackModels}
     * @deprecated
     */</span>
    setTrackedModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.trackModels.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },

    <span class="hljs-comment">/**
     * Binds multiple models to their aliases.
     * @param {Object.&lt;string, external:Backbone-Model&gt;} models A map from alias/name to model to be bound to that alias.
     * @param {boolean} [copy=false] if true, the form model will perform a pull on any mapping using these models.
     */</span>
    trackModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, copy</span>) </span>{
      _.each(models, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">instance, alias</span>) </span>{
        <span class="hljs-keyword">this</span>.trackModel(alias, instance, copy);
      }, <span class="hljs-keyword">this</span>);
    },

    <span class="hljs-comment">/**
     * Use {@link FormModel#untrackModel} instead.
     * @see {@link FormModel#untrackModel}
     * @deprecated
     */</span>
    unsetTrackedModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.untrackModel.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },

    <span class="hljs-comment">/**
     * Removes the binding between a model alias and a model instance. Effectively stops tracking that model.
     * @param {string|external:Backbone-Model} aliasOrModel If a string is given, it will unset the model using that alias. If a model instance
     *   is given, it will unbind whatever alias is currently bound to it.
     */</span>
    untrackModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aliasOrModel</span>) </span>{
      <span class="hljs-keyword">var</span> model,
        alias = <span class="hljs-keyword">this</span>.__findAlias(aliasOrModel);
      <span class="hljs-keyword">if</span> (alias) {
        model = <span class="hljs-keyword">this</span>.__currentObjectModels[alias];
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.__currentObjectModels[alias];
        <span class="hljs-keyword">this</span>.__updateCache(model);
      }
      <span class="hljs-keyword">this</span>.resetUpdating();
    },

    <span class="hljs-comment">/**
     * Use {@link FormModel#untrackModels} instead.
     * @see {@link FormModel#untrackModels}
     * @deprecated
     */</span>
    unsetTrackedModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.untrackModels.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },

    <span class="hljs-comment">/**
     * Removes all the bindings between model aliases and model instances. Effectively stops tracking the current models.
     */</span>
    untrackModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.__currentObjectModels = [];
      <span class="hljs-keyword">this</span>.__updateCache();
      <span class="hljs-keyword">this</span>.resetUpdating();
    },

    <span class="hljs-comment">/**
     * Pushes values from this form model back to the object models it is tracking. This includes invoking the push callbacks from
     * computed values
     */</span>
    push: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      _.each(<span class="hljs-keyword">this</span>.getMappings(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, alias</span>) </span>{
        <span class="hljs-keyword">this</span>.__push(alias);
      }, <span class="hljs-keyword">this</span>);
    },

    <span class="hljs-comment">/**
     * Pulls the most recent values of every object model that this form model tracks including computed values
     * <span class="hljs-doctag">NOTE:</span> using this method can override user-submitted data from an HTML form. Use caution.
     */</span>
    pull: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      _.each(<span class="hljs-keyword">this</span>.getMappings(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, alias</span>) </span>{
        <span class="hljs-keyword">this</span>.__pull(alias);
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.__updateCache();
    },

    <span class="hljs-comment">/**
     * If FormModel has a "url" property defined, it will invoke a save on the form model, and after successfully
     * saving, will perform a push.
     * If no "url" property is defined then the following behavior is used:
     * Pushes the form model values to the object models it is tracking and invokes save on each one. Returns a promise.
     * <span class="hljs-doctag">NOTE:</span> if no url is specified and no models are being tracked, it will instead trigger a 'save-fail' event and reject the returned promise
     * with a payload that mimics a server response: {none: { success: false, response: [{ responseJSON: { generalReasons: [{messageKey: 'no.models.were.bound.to.form'}] }}] }}
     * @param {Object} [options]
     *   @param {boolean} [options.rollback=true] if true, when any object model fails to save, it will revert the object
     *     model attributes to the state they were before calling save. <span class="hljs-doctag">NOTE:</span> if there are updates that happen
     *     to object models within the timing of this save method, the updates could be lost.
     *   @param {boolean} [options.force=true] if false, the form model will check to see if an update has been made
     *     to any object models it is tracking since it's last pull. If any stale data is found, save with throw an exception
     *     with attributes: {name: 'Stale data', staleModels: [Array of model cid's]}
     * @returns when using a "url", a promise is returned for the save on this form model.
         If not using a "url", a promise that will either resolve when all the models have successfully saved in which case the context returned
     *   is an array of the responses (order determined by first the array of models and then the array of models used by
     *   the computed values, normalized), or if any of the saves fail, the promise will be rejected with an array of responses.
     *   Note: the size of the failure array will always be one - the first model that failed. This is a side-effect of $.when
     */</span>
    save: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> notTrackingResponse, url,
        deferred = <span class="hljs-keyword">new</span> $.Deferred(),
        formModel = <span class="hljs-keyword">this</span>;
      options = options || {};
      _.defaults(options, {
        <span class="hljs-attr">rollback</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span>
      });
      <span class="hljs-keyword">try</span> {
        url = _.result(formModel, <span class="hljs-string">'url'</span>);
      } <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>no url attached to this form model. Continue by pushing to models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }
      <span class="hljs-keyword">if</span> (url) {
        <span class="hljs-keyword">return</span> NestedModel.prototype.save.apply(formModel, <span class="hljs-built_in">arguments</span>).done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          formModel.push();
        });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isTrackingAnyObjectModel()) {
        <span class="hljs-keyword">this</span>.__saveToModels(deferred, options);
        <span class="hljs-keyword">return</span> deferred.promise();
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Return a response that is generated when this form model is not tracking an object model</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        notTrackingResponse = {
          <span class="hljs-string">'none'</span>: {
            <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">response</span>: [{
              <span class="hljs-attr">responseJSON</span>: {
                <span class="hljs-attr">generalReasons</span>: [{<span class="hljs-attr">messageKey</span>: <span class="hljs-string">'no.models.were.bound.to.form'</span>}]
              }
            }]
          }
        };
        <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'save-fail'</span>, notTrackingResponse);
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> $.Deferred()).reject(notTrackingResponse).promise();
      }
    },

    <span class="hljs-comment">/**
     * @returns true if this form model is backed by an Object model. That means that at least one object model was bound to an mapping alias.
     */</span>
    isTrackingAnyObjectModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _.size(<span class="hljs-keyword">this</span>.__currentObjectModels) &gt; <span class="hljs-number">0</span>;
    },

    <span class="hljs-comment">/**
     * @returns true if any updates to an object model will immediately copy new values into this form model.
     */</span>
    isUpdating: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__currentUpdateEvents.length &gt; <span class="hljs-number">0</span>;
    },

    <span class="hljs-comment">/**
     * Will add listeners that will automatically pull new updates from this form's object models.
     * @param {boolean} [pullFirst=false] if true, the form model will pull most recent values then start listening
     */</span>
    startUpdating: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pullFirst</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isTrackingAnyObjectModel() &amp;&amp; !<span class="hljs-keyword">this</span>.isUpdating()) {
        <span class="hljs-keyword">if</span> (pullFirst) {
          <span class="hljs-keyword">this</span>.pull();
        }
        <span class="hljs-keyword">this</span>.__setupListeners();
      }
    },

    <span class="hljs-comment">/**
     * This will stop the form model from listening to its object models.
     */</span>
    stopUpdating: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      _.each(<span class="hljs-keyword">this</span>.__currentUpdateEvents, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventConfig</span>) </span>{
        <span class="hljs-keyword">this</span>.stopListening(eventConfig.model, eventConfig.eventName);
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.__currentUpdateEvents = [];
    },

    <span class="hljs-comment">/**
     * If updating, it will reset the updating events to match the current mappings.
     */</span>
    resetUpdating: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isUpdating()) {
        <span class="hljs-keyword">this</span>.stopUpdating();
        <span class="hljs-keyword">this</span>.startUpdating();
      }
    },

    <span class="hljs-comment">/**
     * @param {Backbone.Model} model the backbone model that is being checked
     * @param {Object} [staleModels] a hash that will be updated to contain this model if it is stale in the form: cid -&gt; model.
     * @param {Object} [currentHashValues] If passed an object, it will look in this cache for the current value of the object model
     *   instead of calculating it. It should be key'ed by the model's cid
     * @returns {boolean} true if the model passed in has been changed since the last pull from the object model.
     */</span>
    isModelStale: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, staleModels, currentHashValues</span>) </span>{
      <span class="hljs-keyword">var</span> hashValue;
      currentHashValues = currentHashValues || {};
      <span class="hljs-keyword">if</span> (!currentHashValues[model.cid]) {
        currentHashValues[model.cid] = <span class="hljs-keyword">this</span>.__generateHashValue(model);
      }
      hashValue = currentHashValues[model.cid];
      <span class="hljs-keyword">var</span> isStaleModel = <span class="hljs-keyword">this</span>.__cache[model.cid] !== hashValue;
      <span class="hljs-keyword">if</span> (staleModels) {
        <span class="hljs-keyword">if</span> (isStaleModel) {
          staleModels[model.cid] = model;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (staleModels[model.cid]) {
          <span class="hljs-keyword">delete</span> staleModels[model.cid];
        }
      }
      <span class="hljs-keyword">return</span> isStaleModel;
    },

    <span class="hljs-comment">/**
     * @returns {Array} an array of the object models that have been updated since the last pull from this form model
     */</span>
    checkIfModelsAreStale: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> staleModels = {},
        currentHashValues = <span class="hljs-keyword">this</span>.__generateAllHashValues();
      _.each(<span class="hljs-keyword">this</span>.getTrackedModels(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        <span class="hljs-keyword">this</span>.isModelStale(model, staleModels, currentHashValues);
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> _.values(staleModels);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><strong><strong><strong>**</strong></strong></strong> Private methods <strong><strong><strong>**</strong></strong></strong>//</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-comment">/**
     * Sets up a listener to update the form model if the model's field (or any field) changes.
     * @param {Backbone.Model} model the object model from which this form model will start listen to changes
     * @param {string} [field] the field name that it will start listening to. If no field is given, it will listen to the general 'change' event.
     * @private
     */</span>
    __listenToModelField: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, field</span>) </span>{
      <span class="hljs-keyword">var</span> callback, eventName;
      <span class="hljs-keyword">if</span> (field) {
        eventName = <span class="hljs-string">'change:'</span> + field;
        callback = _.bind(<span class="hljs-keyword">this</span>.__updateFormField, {
          <span class="hljs-attr">formModel</span>: <span class="hljs-keyword">this</span>,
          <span class="hljs-attr">field</span>: field
        });
      } <span class="hljs-keyword">else</span> {
        eventName = <span class="hljs-string">'change'</span>;
        callback = <span class="hljs-keyword">this</span>.__updateFormModel;
      }
      <span class="hljs-keyword">this</span>.listenTo(model, eventName, callback);
      <span class="hljs-keyword">this</span>.__currentUpdateEvents.push({<span class="hljs-attr">model</span>: model, <span class="hljs-attr">eventName</span>: eventName});
    },

    <span class="hljs-comment">/**
     * Sets up a listener on one (or all) of the fields that is needed to update a computed value
     * @param {Backbone.Model} model the object model from which this form model will start listen to changes
     * @param {string} [field] the field name that it will start listening to. If no field is given, it will listen to the general 'change' event.
     * @param {string} computedAlias the name/alias of the computed mapping being used.
     * @private
     */</span>
    __listenToComputedValuesDependency: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, field, computedAlias</span>) </span>{
      <span class="hljs-keyword">var</span> callback, eventName;
      <span class="hljs-keyword">if</span> (field) {
        eventName = <span class="hljs-string">'change:'</span> + field;
      } <span class="hljs-keyword">else</span> {
        eventName = <span class="hljs-string">'change'</span>;
      }
      callback = _.bind(<span class="hljs-keyword">this</span>.__invokeComputedPull, {
        <span class="hljs-attr">formModel</span>: <span class="hljs-keyword">this</span>,
        <span class="hljs-attr">alias</span>: computedAlias
      });
      <span class="hljs-keyword">this</span>.listenTo(model, eventName, callback);
      <span class="hljs-keyword">this</span>.__currentUpdateEvents.push({<span class="hljs-attr">model</span>: model, <span class="hljs-attr">eventName</span>: eventName});
    },

    <span class="hljs-comment">/**
     * Returns the models that a currently being tracked that are part of a computed mapping
     * If there is a missing model (a model alias is referenced but no model instance is bound to that alias), then it will return undefined.
     * @param {string} computedAlias the name/alias of the computed mapping
     * @returns {Object} a map from model name/alias to model instance. If there is a missing model (an model alias is referenced but no model
     *   instance is bound to that alias), then it will return undefined.
     * @private
     */</span>
    __getComputedModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">computedAlias</span>) </span>{
      <span class="hljs-keyword">var</span> hasAllModels = !_.isUndefined(<span class="hljs-keyword">this</span>.getMapping(computedAlias)),
        models = {};
      _.each(<span class="hljs-keyword">this</span>.__getModelAliases(computedAlias), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
        <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(modelAlias);
        <span class="hljs-keyword">if</span> (model) {
          models[modelAlias] = model;
        } <span class="hljs-keyword">else</span> {
          hasAllModels = <span class="hljs-literal">false</span>;
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> hasAllModels ? models : <span class="hljs-literal">undefined</span>;
    },

    <span class="hljs-comment">/**
     * Returns the aliases/names of models referenced in the computed mapping with the given alias
     * @param {(string|Object)} computedAliasOrConfig the name/alias of the computed mapping or the computed mapping itself as
     *   an object if it hasn't been added as a mapping yet.
     * @returns {string[]} an array of the model names/aliases referenced inside the computed mapping
     * @private
     */</span>
    __getModelAliases: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">computedAliasOrConfig</span>) </span>{
      <span class="hljs-keyword">var</span> config,
        modelAliases = [];
      <span class="hljs-keyword">if</span> (_.isString(computedAliasOrConfig)) {
        config = <span class="hljs-keyword">this</span>.getMapping(computedAliasOrConfig);
      } <span class="hljs-keyword">else</span> {
        config = computedAliasOrConfig;
      }
      <span class="hljs-keyword">return</span> _.filter(_.keys(config.mapping), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
        <span class="hljs-keyword">return</span> key != <span class="hljs-string">'pull'</span> &amp;&amp; key != <span class="hljs-string">'push'</span>;
      });
    },

    <span class="hljs-comment">/**
     * Repackages a computed mapping to be easier consumed by methods wanting the model mappings tied to the model instances.
     * Returns a list of objects that contain the model instance and the mapping for that model.
     *
     * @private
     * @param {string} computedAlias the name/alias used for this computed
     * @returns {object[]} a list of objects that contain the model instance under "model" and the mapping for that model under "fields".
     */</span>
    __getComputedModelConfigs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">computedAlias</span>) </span>{
      <span class="hljs-keyword">var</span> hasAllModels = <span class="hljs-literal">true</span>,
        config = <span class="hljs-keyword">this</span>.getMapping(computedAlias),
        modelConfigs = [];
      _.each(<span class="hljs-keyword">this</span>.__getModelAliases(computedAlias), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
        <span class="hljs-keyword">var</span> modelConfig = <span class="hljs-keyword">this</span>.__createModelConfig(modelAlias, config.mapping[modelAlias]);
        <span class="hljs-keyword">if</span> (modelConfig) {
          modelConfigs.push(modelConfig);
        } <span class="hljs-keyword">else</span> {
          hasAllModels = <span class="hljs-literal">false</span>;
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> hasAllModels ? modelConfigs : <span class="hljs-literal">undefined</span>;
    },

    <span class="hljs-comment">/**
     * Pushes the form model values to the object models it is tracking and invokes save on each one. Returns a promise.
     * @param {Object} [options]
     *   @param {boolean} [options.rollback=true] if true, when any object model fails to save, it will revert the object
     *     model attributes to the state they were before calling save. <span class="hljs-doctag">NOTE:</span> if there are updates that happen
     *     to object models within the timing of this save method, the updates could be lost.
     *   @param {boolean} [options.force=true] if false, the form model will check to see if an update has been made
     *     to any object models it is tracking since it's last pull. If any stale data is found, save with throw an exception
     *     with attributes: {name: 'Stale data', staleModels: [Array of model cid's]}
     * @returns a promise that will either resolve when all the models have successfully saved in which case the context returned
     *   is an array of the responses (order determined by first the array of models and then the array of models used by
     *   the computed values, normalized), or if any of the saves fail, the promise will be rejected with an array of responses.
     *   Note: the size of the failure array will always be one - the first model that failed. This is a side-effect of $.when
     * @private
     */</span>
    __saveToModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">deferred, options</span>) </span>{
      <span class="hljs-keyword">var</span> staleModels,
        formModel = <span class="hljs-keyword">this</span>,
        responsesSucceeded = <span class="hljs-number">0</span>,
        responsesFailed = <span class="hljs-number">0</span>,
        responses = {},
        oldValues = {},
        models = formModel.getTrackedModels(),
        numberOfSaves = models.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If we’re not forcing a save, then throw an error if the models are stale</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!options.force) {
        staleModels = formModel.checkIfModelsAreStale();
        <span class="hljs-keyword">if</span> (staleModels.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">throw</span> {
            <span class="hljs-attr">name</span>: <span class="hljs-string">'Stale data'</span>,
            <span class="hljs-attr">staleModels</span>: staleModels
          };
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Callback for each response</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">responseCallback</span>(<span class="hljs-params">response, model, success</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Add response to a hash that will eventually be returned through the promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        responses[model.cid] = {
            <span class="hljs-attr">success</span>: success,
            <span class="hljs-attr">response</span>: response
          };</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If we have reached the total of number of expected responses, then resolve or reject the promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (responsesFailed + responsesSucceeded === numberOfSaves) {
          <span class="hljs-keyword">if</span> (responsesFailed &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Rollback if any responses have failed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (options.rollback) {
              _.each(formModel.getTrackedModels(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
                model.set(oldValues[model.cid]);
                <span class="hljs-keyword">if</span> (responses[model.cid].success) {
                  model.save();
                }
              });
            }
            formModel.trigger(<span class="hljs-string">'save-fail'</span>, responses);
            deferred.reject(responses);
          } <span class="hljs-keyword">else</span> {
            formModel.trigger(<span class="hljs-string">'save-success'</span>, responses);
            deferred.resolve(responses);
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Grab the current values of the object models</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.each(models, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        oldValues[model.cid] = formModel.__getTrackedModelFields(model);
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Push the form model values to the object models</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      formModel.push();</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Call save on each object model</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.each(models, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        model.save().fail(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          responsesFailed++;
          responseCallback(<span class="hljs-built_in">arguments</span>, model, <span class="hljs-literal">false</span>);
        }).done(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          responsesSucceeded++;
          responseCallback(<span class="hljs-built_in">arguments</span>, model, <span class="hljs-literal">true</span>);
        });
      });
    },

    <span class="hljs-comment">/**
     * Pulls in new information from tracked models using the mapping defined by the given alias.
     * This works for both model mappings and computed value mappings
     * @param {string} alias the name of the mapping that will be used during the pull
     * @private
     */</span>
    __pull: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias</span>) </span>{
      <span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.getMapping(alias);
      <span class="hljs-keyword">if</span> (config.computed &amp;&amp; config.mapping.pull) {
        <span class="hljs-keyword">this</span>.__invokeComputedPull.call({<span class="hljs-attr">formModel</span>: <span class="hljs-keyword">this</span>, <span class="hljs-attr">alias</span>: alias});
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.computed) {
        <span class="hljs-keyword">var</span> modelAliases = <span class="hljs-keyword">this</span>.__getModelAliases(alias);
        _.each(modelAliases, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
          <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(modelAlias);
          <span class="hljs-keyword">if</span> (model) {
            <span class="hljs-keyword">this</span>.__copyFields(config.mapping[modelAlias], <span class="hljs-keyword">this</span>, model);
          }
        }, <span class="hljs-keyword">this</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(alias);
        <span class="hljs-keyword">if</span> (model) {
          <span class="hljs-keyword">this</span>.__copyFields(config.mapping, <span class="hljs-keyword">this</span>, model);
        }
      }
    },

    <span class="hljs-comment">/**
     * Pushes form model information to tracked models using the mapping defined by the given alias.
     * This works for both model mappings and computed value mappings
     * @param {string} alias the name of the mapping that will be used during the push
     * @private
     */</span>
    __push: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alias</span>) </span>{
      <span class="hljs-keyword">var</span> config = <span class="hljs-keyword">this</span>.getMapping(alias);
      <span class="hljs-keyword">if</span> (config.computed &amp;&amp; config.mapping.push) {
        <span class="hljs-keyword">var</span> models = <span class="hljs-keyword">this</span>.__getComputedModels(alias);
        <span class="hljs-keyword">if</span> (models) {
          config.mapping.push.call(<span class="hljs-keyword">this</span>, models);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config.computed) {
        <span class="hljs-keyword">var</span> modelAliases = <span class="hljs-keyword">this</span>.__getModelAliases(alias);
        _.each(modelAliases, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
          <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(modelAlias);
          <span class="hljs-keyword">if</span> (model) {
            <span class="hljs-keyword">this</span>.__copyFields(config.mapping[modelAlias], model, <span class="hljs-keyword">this</span>);
          }
        }, <span class="hljs-keyword">this</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(alias);
        <span class="hljs-keyword">if</span> (model) {
          <span class="hljs-keyword">this</span>.__copyFields(config.mapping, model, <span class="hljs-keyword">this</span>);
        }
      }
    },

    <span class="hljs-comment">/**
     * Updates a single attribute in this form model.
     * <span class="hljs-doctag">NOTE:</span> requires the context of this function to be:
     * {
     *  formModel: &lt;this form model&gt;,
     *  field: &lt;the field being updated&gt;
     * }
     * NOT the form model itself like if you called this.__updateFormField.
     * @private
     */</span>
    __updateFormField: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, value</span>) </span>{
      <span class="hljs-keyword">this</span>.formModel.set(<span class="hljs-keyword">this</span>.field, value);
      <span class="hljs-keyword">this</span>.formModel.__updateCache(model);
    },

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">NOTE:</span> When looking to update the form model manually, call this.pull().
     * Updates this form model with the changed attributes of a given object model
     * @param {external:Backbone-Model} model the object model that has been changed
     * @private
     */</span>
    __updateFormModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      _.each(model.changedAttributes(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, fieldName</span>) </span>{
        <span class="hljs-keyword">this</span>.set(fieldName, <span class="hljs-keyword">this</span>.__cloneVal(value));
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.__updateCache(model);
    },

    <span class="hljs-comment">/**
     * Updates the form model's snapshot of the model's attributes to use later
     * @param {external:Backbone-Model} model the object model
     * @param {Object} [cache=this.__cache] if passed an object (can be empty), this method will fill
     *   this cache object instead of this form model's __cache field
     * @private
     */</span>
    __updateCache: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">if</span> (!model) {
        <span class="hljs-keyword">this</span>.__cache = {};
        _.each(<span class="hljs-keyword">this</span>.getTrackedModels(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
          <span class="hljs-keyword">if</span> (model) {
            <span class="hljs-keyword">this</span>.__updateCache(model);
          }
        }, <span class="hljs-keyword">this</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.__cache[model.cid] = <span class="hljs-keyword">this</span>.__generateHashValue(model);
      }
    },

    <span class="hljs-comment">/**
     * Create a hash value of a simple object
     * @param {Object} obj simple object with no functions
     * @returns a hash value of the object
     * @private
     */</span>
    __hashValue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(obj);
    },

    <span class="hljs-comment">/**
     * Returns the alias/name bound to the model passed in. If a string is passed in, it will just return this string.
     * @param {string|external:Backbone-Model} aliasOrModel If string, just returns this string. If a model instance, then the alias
     *   that is bound to the tracked model passed in will be found and returned.
     * @returns {string} the alias
     * @private
     */</span>
    __findAlias: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aliasOrModel</span>) </span>{
      <span class="hljs-keyword">var</span> alias, objectModel;
      <span class="hljs-keyword">if</span> (_.isString(aliasOrModel)) {
        alias = aliasOrModel;
      } <span class="hljs-keyword">else</span> {
        objectModel = aliasOrModel;
        alias = _.find(<span class="hljs-keyword">this</span>.__currentObjectModels, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
          <span class="hljs-keyword">return</span> model == objectModel;
        });
      }
      <span class="hljs-keyword">return</span> alias;
    },

    <span class="hljs-comment">/**
     * @param {external:Backbone-Model} model the model to create the hash value from
     * @returns {string} the hash value of the model making sure to only use the tracked fields
     * @private
     */</span>
    __generateHashValue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">var</span> modelFields = <span class="hljs-keyword">this</span>.__getTrackedModelFields(model);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__hashValue(modelFields);
    },

    <span class="hljs-comment">/**
     * @returns {Object} a map of model's cid to the hash value of the model making sure to only use the tracked fields
     * @private
     */</span>
    __generateAllHashValues: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> currentHashValues = {};
      _.each(<span class="hljs-keyword">this</span>.getTrackedModels(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
        currentHashValues[model.cid] = <span class="hljs-keyword">this</span>.__generateHashValue(model);
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> currentHashValues;
    },

    <span class="hljs-comment">/**
     * Deep clones the attributes. There should be no functions in the attributes
     * @param {(Object|Array|string|number|boolean)} val a non-function value
     * @returns the clone
     * @private
     */</span>
    __cloneVal: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
      <span class="hljs-keyword">var</span> seed;
      <span class="hljs-keyword">if</span> (_.isArray(val)) {
        seed = [];
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isObject(val)) {
        seed = {};
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> val;
      }
      <span class="hljs-keyword">return</span> $.extend(<span class="hljs-literal">true</span>, seed, val);
    },

    <span class="hljs-comment">/**
     * Attaches listeners to the tracked object models with callbacks that will copy new properties into this form model.
     * @private
     */</span>
    __setupListeners: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> model, modelConfigs,
        formModel = <span class="hljs-keyword">this</span>;
      _.each(formModel.getMappings(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, alias</span>) </span>{
        <span class="hljs-keyword">if</span> (config.computed) {
          modelConfigs = formModel.__getComputedModelConfigs(alias);
          _.each(modelConfigs, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelConfig</span>) </span>{
            <span class="hljs-keyword">var</span> model = modelConfig.model;
            <span class="hljs-keyword">if</span> (modelConfig.fields) {
              _.each(modelConfig.fields, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
                formModel.__listenToComputedValuesDependency(model, field, alias);
              });
            } <span class="hljs-keyword">else</span> {
              formModel.__listenToComputedValuesDependency(model, <span class="hljs-string">''</span>, alias);
            }
          });
        } <span class="hljs-keyword">else</span> {
          model = formModel.getTrackedModel(alias);
          <span class="hljs-keyword">if</span> (model) {
            <span class="hljs-keyword">if</span> (config.mapping) {
              _.each(config.mapping, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
                formModel.__listenToModelField(model, field);
              });
            } <span class="hljs-keyword">else</span> {
              formModel.__listenToModelField(model);
            }
          }
        }
      });
    },

    <span class="hljs-comment">/**
     * Copies fields from one backbone model to another. Is useful during a pull or push to/from Object models. The values will
     * be deep cloned from the origin to the destination.
     * @param {Array} [fields] a string of attribute names on the origin model that will be copied. Leave null if all attributes
     *   are to be copied
     * @param {Backbone.Model} destination the backbone model that will have values copied into
     * @param {Backbone.Model} origin the backbone model that will be used to grab values.
     * @private
     */</span>
    __copyFields: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fields, destination, origin</span>) </span>{
      <span class="hljs-keyword">if</span> ((!fields || fields === <span class="hljs-literal">true</span>) &amp;&amp; <span class="hljs-keyword">this</span> === origin &amp;&amp; _.size(<span class="hljs-keyword">this</span>.getTrackedModels()) &gt; <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>only copy attributes that exist on object model when the form model is tracking all the properties
of that object model, but is also tracking other models as well.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        fields = _.keys(destination.attributes);
      }
      <span class="hljs-keyword">if</span> (fields) {
        _.each(fields, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
          destination.set(field, <span class="hljs-keyword">this</span>.__cloneVal(origin.get(field)));
        }, <span class="hljs-keyword">this</span>);
      } <span class="hljs-keyword">else</span> {
        destination.set(<span class="hljs-keyword">this</span>.__cloneVal(origin.attributes));
      }
    },

    <span class="hljs-comment">/**
     * Sets the mapping using the form model's default mapping or the options.mappings if available.
     * Also sets the tracked models if the form model's default models or the options.models is provided.
     * @param {Object} [options] See initialize options: 'mapping' and 'models'.
     * @private
     */</span>
    __initMappings: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> mapping,
        models,
        defaultMapping = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'mapping'</span>),
        defaultModels = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'models'</span>);
      mapping = options.mapping || defaultMapping;
      models = options.models || defaultModels;
      <span class="hljs-keyword">if</span> (mapping) {
        <span class="hljs-keyword">this</span>.setMappings(mapping, models);
      }
    },

    <span class="hljs-comment">/**
     * Returns a map where the keys are the fields that are being tracked on tracked model and values are
     * the with current values of those fields.
     * @param {external:Backbone-Model} model the object model
     * @returns {Object} aa map where the keys are the fields that are being tracked on tracked model and
     *   values are the with current values of those fields.
     * @private
     */</span>
    __getTrackedModelFields: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">var</span> allFields,
        fieldsUsed = {},
        modelFields = {},
        modelConfigs = [];
      _.each(<span class="hljs-keyword">this</span>.__getAllModelConfigs(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelConfig</span>) </span>{
        <span class="hljs-keyword">if</span> (modelConfig.model &amp;&amp; modelConfig.model.cid === model.cid) {
          modelConfigs.push(modelConfig);
        }
      });
      allFields = _.reduce(modelConfigs, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, modelConfig</span>) </span>{
        <span class="hljs-keyword">return</span> result || !modelConfig.fields;
      }, <span class="hljs-literal">false</span>);
      <span class="hljs-keyword">if</span> (allFields) {
        modelFields = <span class="hljs-keyword">this</span>.__cloneVal(model.attributes);
      } <span class="hljs-keyword">else</span> {
        _.each(modelConfigs, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelConfig</span>) </span>{
          _.each(modelConfig.fields, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
            <span class="hljs-keyword">if</span> (!fieldsUsed[field]) {
              fieldsUsed[field] = <span class="hljs-literal">true</span>;
              modelFields[field] = <span class="hljs-keyword">this</span>.__cloneVal(model.get(field));
            }
          }, <span class="hljs-keyword">this</span>);
        }, <span class="hljs-keyword">this</span>);
      }
      <span class="hljs-keyword">return</span> modelFields;
    },

    <span class="hljs-comment">/**
     * Returns a useful data structure that binds a tracked model to the fields being tracked on a mapping.
     * @param modelAlias
     * @param {(string[]|undefined)} fields the fields that the model is tracking. Can be undefined if tracking all fields.
     *   When creating a model config for a computed mapping, the fields refers to the fields being tracked only for that computed value.
     * @returns {Object} a binding between a tracked model and the fields its tracking for a mapping. If no tracked model is bound to the modelAlias,
     *   it will return undefined.
     * @private
     */</span>
    __createModelConfig: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias, fields</span>) </span>{
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.getTrackedModel(modelAlias);
      <span class="hljs-keyword">if</span> (model) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">fields</span>: fields,
          <span class="hljs-attr">model</span>: model
        };
      }
    },

    <span class="hljs-comment">/**
     * Returns an array of convenience data structures that bind tracked models to the fields they are tracking for each mapping,
     * including model mappings inside computed mappings. There will be a model config for each tracked model on a computed mapping
     * meaning there can be multiple model configs for the same tracked model.
     * @returns {Array} array of convenience data structures that bind tracked models to the fields they are tracking for each mapping,
     *   including model mappings inside computed mappings.
     * @private
     */</span>
    __getAllModelConfigs: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> modelConfigs = [];
      _.each(<span class="hljs-keyword">this</span>.getMappings(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config, alias</span>) </span>{
        <span class="hljs-keyword">if</span> (config.computed) {
          <span class="hljs-keyword">var</span> computedModelConfigs = <span class="hljs-keyword">this</span>.__getComputedModelConfigs(alias);
          <span class="hljs-keyword">if</span> (computedModelConfigs) {
            modelConfigs = modelConfigs.concat(computedModelConfigs);
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> modelConfig = <span class="hljs-keyword">this</span>.__createModelConfig(alias, config.mapping);
          <span class="hljs-keyword">if</span> (modelConfig) {
            modelConfigs.push(modelConfig);
          }
        }
      }, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> modelConfigs;
    },

    <span class="hljs-comment">/**
     * A wrapper function that can invoke the pull callback on a computed mapping during an event callback.
     * Because an event callback predetermines the argument list, this method assumes the necessary computed configuration is
     * bound as the part of the function context.
     * When invoking the pull callback, it will pass in a object map from model alias to shallow copy of the tracked fields the
     * computed value uses. It is NOT just the model, but a  copy of its attributes - feel free to change the properties.
     * Example:
     * fooBar: {
     *   myModel: 'foo bar',
     *   pull: function(models) {
     *     console.log(models.myModel.foo, models.myModel.bar)
     *   }
     * }
     * If any model mapping is tracking all fields by passing true as its config, a copy of all the attributes for that model will be provided.
     * @param {Backbone.Model} [model] the model that was updated. If provided, the cache will be updated
     * <span class="hljs-doctag">NOTE:</span> requires the context of this function to be:
     * {
     *  formModel: &lt;this form model&gt;,
     *  alias: &lt;the computed alias&gt;,
     * }
     * @private
     */</span>
    __invokeComputedPull: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">if</span> (model) {
        <span class="hljs-keyword">this</span>.formModel.__updateCache(model);
      }
      (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">formModel, alias</span>) </span>{
        <span class="hljs-keyword">var</span> hasAllModels = <span class="hljs-literal">true</span>,
          config = formModel.getMapping(alias),
          modelAliases = formModel.__getModelAliases(alias),
          models = {};
        <span class="hljs-keyword">if</span> (!config.mapping.pull) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">console</span> &amp;&amp; _.isFunction(<span class="hljs-built_in">console</span>.log)) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Not pulling the computed: '</span> + alias + <span class="hljs-string">', because no pull method was defined for this computed.'</span>);
          }
          <span class="hljs-keyword">return</span>;
        }
        _.each(modelAliases, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modelAlias</span>) </span>{
          <span class="hljs-keyword">var</span> fields = config.mapping[modelAlias],
            model = formModel.getTrackedModel(modelAlias),
            modelCopy = {};
          <span class="hljs-keyword">if</span> (!model) {
            hasAllModels = <span class="hljs-literal">false</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (fields) {
              _.each(fields, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">field</span>) </span>{
                modelCopy[field] = formModel.__cloneVal(model.get(field));
              });
            } <span class="hljs-keyword">else</span> {
              modelCopy = formModel.__cloneVal(model.attributes);
            }
            models[modelAlias] = modelCopy;
          }
        });
        <span class="hljs-keyword">if</span> (hasAllModels) {
          config.mapping.pull.call(formModel, models);
        }
      })(<span class="hljs-keyword">this</span>.formModel, <span class="hljs-keyword">this</span>.alias);
    }
  });

  _.extend(FormModel.prototype, validation.mixin);

  <span class="hljs-keyword">return</span> FormModel;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
